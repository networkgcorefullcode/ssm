# Deployment of the SSM with Aether Core

![alt text](../img/image4.png)
Figure 1: Architecture of the SSM integrated with UDM and Webconsole

Below is a set of steps to deploy the SSM so it can be used by Aether components.

## 1. Suggested Prerequisites

1- Ubuntu Server 24.04 LTS (4 cores, 16 GB RAM, 60 GB disk)

These resources are recommended for a more stable environment, but simulations have been done with fewer resources (2 cores and 8 GB RAM) and it works correctly for test and small demo environments.

2- MongoDB 7.0 Community Edition deployed as a ReplicaSet

(See [MongoDB Installation on Ubuntu 24.04](../../commandsAndManagament/installing_mongodb_ubuntu24.04.md))

3- SoftHSM2 installed and configured

(See [SoftHSM2 Installation](../../commandsAndManagament/installing_softHSM.md))

(See [SoftHSM2 PKCS#11 Commands](../../commandsAndManagament/softhsm_pkcs11_commands.md))

## 2. Start the SSM

1- Download the SSM binary from the GitLab releases page or build it from source.

If you download the source code simply go to the project root directory and run:

```bash
go build -o ssm ./ssm.go
```

2- Create the configuration file `ssmConfig.yml` with the required parameters for connection to SoftHSM2 and MongoDB, as well as the security parameters.

From source code you can use the configuration template located in the `factory` directory and adapt it to your needs.

```bash
vim factory/ssmConfig.yml
```

## 3. Deploy Aether Core

1- Generate TLS certificates for the SSM and the other components (if HTTPS is desired).

See [TLS Certificate Generation](../../commandsAndManagament/gen_certificates_mTLS1.3.md)

Use the `server.*` certificates for the SSM.

2- Deploy the SSM with the created configuration.

```bash
./ssm --cfg factory/ssmConfig.yml
```

3- Deploy Aether Core

This step depends on the method you use to deploy Aether Core. We suggest using Aether OnRamp following the official Aether guide and the documentation generated by us.

Before deploying Aether Core, you must generate new secrets for the Webconsole and UDM.

Use the following template of commands to execute:

```bash
kubectl create secret generic udm-tls \
  --from-file=tls.crt=/var/certs/client-udm.crt \
  --from-file=tls.key=/var/certs/client-udm.key \
  --from-file=ca.crt=/var/certs/ca.crt \
  --namespace aether-5gc

kubectl create secret generic udm-credentials \
  --from-literal=service_id='<your_service_id>' \
  --from-literal=password='<your_password>' \
  --namespace aether-5gc

kubectl create secret generic webui-tls \
  --from-file=tls.crt=/var/certs/client-webconsole.crt \
  --from-file=tls.key=/var/certs/client-webconsole.key \
  --from-file=ca.crt=/var/certs/ca.crt \
  --namespace aether-5gc

kubectl create secret generic webui-credentials \
  --from-literal=service_id='<your_service_id>' \
  --from-literal=password='<your_password>' \
  --namespace aether-5gc
```
For this deployment it is necessary to use Helm charts different from those that come by default in Aether OnRamp, since it is necessary to configure security parameters so that the Webconsole and UDM can communicate with the SSM.

These customized Helm charts are not yet publicly available, so you must create them yourself following the official Aether OnRamp documentation and adapting the necessary values for SSM configuration. A critical pending implementation is to publish these charts in a public repository to facilitate their use.

Make sure to correctly configure the connection parameters to the SSM in the Helm chart values, including the MongoDB connection URL, TLS certificates and required credentials.

Below is an example of how the Helm chart values would look for the UDM and Webconsole:

```yaml
webui:
      tlsSecretName: "webui-tls"
      tlsSecretKeys:
        cert: tls.crt
        key: tls.key
        ca: ca.crt
      credentialsSecretName: "webui-credentials"
      ssm:
        enable: true
      credentials:
        serviceIdKey: service_id
        passwordKey: password
      serviceType: NodePort
      deploy: true
      urlport:
        port: 5000
        
        nodePort: 30001
      rest:
        port: 5001
        
        nodePort: 30002
      ingress:
        enabled: false
        hostname: aether.local
        path: /
        pathType: Prefix
        # extraHosts:
          # - host: aether.local
          #   path: /
      cfgFiles:
        webuicfg.yaml:
          info:
            version: 1.0.0
            description: WebUI initial local configuration
          configuration:
            # 5G mode
            spec-compliant-sdf: false
            enableAuthentication: false
            send-pebble-notifications: false
            # MongoDB configuration
            mongodb:
              name: aether
              url: "mongodb://mongodb-arbiter-headless"
              authKeysDbName: authentication
              authUrl: "mongodb://mongodb-arbiter-headless"
              webuiDbName: aether
              webuiDbUrl: "mongodb://mongodb-arbiter-headless"
              checkReplica: false
            enableAuthentication: false
            spec-compliant-sdf: false
            webui-tls:
              pem: /var/run/certs/tls.crt
              key: /var/run/certs/tls.key
            nfconfig-tls:
              pem: /var/run/certs/tls.crt
              key: /var/run/certs/tls.key
            managedByConfigPod:
              syncUrl: http://roc-service:8080/sync
              enabled: false
            ssm:
              ssm-uri: https://192.168.12.16:9000
              allow-ssm: true
              tls-insecure: true
              ssm-synchronize:
                enable: true
                interval-minute: 30
                max-keys-create: 5
                delete-missing: true
                max-sync-keys: 5
                max-sync-users: 5
                max-sync-rotations: 5
              m-tls:
                crt: /etc/webui/tls/tls.crt
                key: /etc/webui/tls/tls.key
                ca: /etc/webui/tls/ca.crt
              # read in cascade if gcm is false then cbc is used if gcm is true cbc is ignored, both is false no encryption is used (disabled SSM jjjj)
              is-encrypt-aes-gcm: true
              is-encrypt-aes-cbc: false
            metricsPort: ":8080"

    udm:
      deploy: true
      serviceType: ClusterIP
      credentialsSecretName: "udm-credentials"
      tlsSecretName: "udm-tls"
      tlsSecretKeys:
        cert: tls.crt
        key: tls.key
        ca: ca.crt
      ssm:
        enable: true
      credentials:
        serviceIdKey: service_id
        passwordKey: password
      sbi:
        port: 29503
      cfgFiles:
        udmcfg.yaml:
          info:
            version: 1.0.0
            description: UDM initial local configuration
          configuration:
            nrfUri: https://nrf:29510
            webuiUri: https://webui.aether-5gc:5001
            enableNrfCaching: true
            nrfCacheEvictionInterval: 900
            serviceList:
              - nudm-sdm
              - nudm-uecm
              - nudm-ueau
              - nudm-ee
              - nudm-pp
            sbi:
              scheme: https
              bindingIPv4: "0.0.0.0"
              registerIPv4: udm
              tls:
                pem: /var/run/certs/tls.crt
                key: /var/run/certs/tls.key
            keys:
              udmProfileAHNPublicKey: 5a8d38864820197c3394b92613b20b91633cbd897119273bf8e4a6f4eec0a650
              udmProfileAHNPrivateKey: c53c22208b61860b06c62e5406a7b330c2b577aa5558981510d128247d38bd1d
              udmProfileBHNPublicKey: 0472DA71976234CE833A6907425867B82E074D44EF907DFB4B3E21C1C2256EBCD15A7DED52FCBB097A4ED250E036C7B9C8C7004C4EEDC4F068CD7BF8D3F900E3B4
              udmProfileBHNPrivateKey: F1AB1074477EBCC7F554EA1C5FC368B1616730155E0041AC447D6301975FECDA
            ssm:
              enable: true
              host: https://192.168.12.16:9000
              tls_insecure: true
              m-tls:
                crt: /etc/udm/tls/tls.crt
                key: /etc/udm/tls/tls.key
                ca: /etc/udm/tls/ca.crt
            metricsPort: ":8080" 
```

With all this implemented you should now have the SSM running and ready to be used by Aether Core's UDM and Webconsole. You only need to execute the Aether OnRamp deployment command with the new charts and configured values.

## Deployment Suggestions

1- Automate steps using Ansible
2- Implement CI/CD for the SSM
3- Publish the customized Helm charts in a public repository and document each chart version
